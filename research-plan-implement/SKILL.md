---
name: research-plan-implement
description: 実装計画を立てるためのワークフロースキル。Research → Plan → Annotate → Todo → Implement → Feedback の6フェーズで、コードを書く前に計画を練り上げる。トリガー：「実装計画」「計画を立てて」「plan.md」「research.md」「調査して」「計画作って」「プランニング」「設計して」「アーキテクチャ」「方針を決めて」。新機能追加、大規模リファクタリング、複雑なバグ修正など、事前調査と計画が必要な作業で自動適用。
---

# Research-Plan-Implement ワークフロー

コードを書く前に計画を練り上げ、ユーザーの判断を注入するワークフロー。
実装フェーズに入ったら `$implementation-rules` に制御を渡す。

## ワークフロー概要

```
Research → Plan → Annotate(1-6回) → Todo List → Implement → Feedback
```

## Phase 1: Research（深い調査）

対象コードベースを徹底的に読み込み、`research.md` に調査結果を出力する。

### 実行手順

1. 対象フォルダ/ファイルを**深く**読み込む（表面的なスキミング禁止）
2. 以下を網羅的に調査:
   - アーキテクチャ・設計パターン
   - データフロー・状態管理
   - 既存の規約・慣習（命名、エラーハンドリング等）
   - キャッシュ・リトライ等の横断的関心事
   - 潜在的なバグや技術的負債
3. 調査結果を `research.md` に出力（チャットの口頭サマリーではなく**ファイルとして永続化**）

### research.md の構成

```markdown
# リサーチ: [対象領域]

## 概要
[全体像の1段落サマリー]

## アーキテクチャ
[コンポーネント構成、依存関係]

## データフロー
[入出力、状態遷移、データ変換]

## 既存の規約・パターン
[プロジェクトで使われている慣習]

## 注意点・制約
[変更時に壊れやすい箇所、暗黙の前提]

## 発見事項
[バグ候補、改善余地、技術的負債]
```

> **重要**: research.md はユーザーのレビュー対象。ユーザーが読んで理解が正しいか検証できる粒度で書く。

## Phase 2: Planning（計画文書作成）

research.md のレビューが完了したら、`plan.md` を作成する。

### 実行手順

1. research.md を踏まえ、実装アプローチを設計
2. 以下を含む `plan.md` を作成:
   - 実装アプローチの説明
   - 変更対象ファイルの一覧
   - **具体的なコードスニペット**（実際の変更内容を示す）
   - トレードオフ・考慮事項
3. **まだ実装しない**

### plan.md の構成

```markdown
# 実装計画: [機能名/変更内容]

## アプローチ
[何をどう実装するかの概要]

## 変更内容

### [コンポーネント/ファイル名]
[変更の説明]
```コードスニペット```

### [コンポーネント/ファイル名]
[変更の説明]
```コードスニペット```

## 考慮事項
- [トレードオフ、エッジケース、互換性]

## Todo List
（Phase 4で追加）
```

### リファレンス実装の活用

既存のOSSや社内コードに良い実装例がある場合、ユーザーから参照コードを受け取って計画に反映する。ゼロから設計するより、実績ある実装を参考にした方が品質が高い。

## Phase 3: Annotation Cycle（注釈サイクル）

**このワークフローの核心。** ユーザーが `plan.md` に直接注釈を書き込み、AIがそれを反映する反復プロセス。

### フロー

1. ユーザーが `plan.md` をエディタで開き、インライン注釈を追加
2. 「注釈を追加した、反映して」という指示を受ける
3. 全注釈を確認し、plan.md を更新
4. ユーザーが満足するまで繰り返し（1-6回）
5. **「実装して」と言われるまで絶対に実装しない**

### 注釈の例

- `"ここはPATCHではなくPUTで"` — 技術的選択の修正
- `"このセクション削除、キャッシュ不要"` — アプローチの却下
- `"drizzle:generate使って、生SQL禁止"` — ドメイン知識の注入
- `"任意ではなく必須"` — 2語の簡潔な修正
- `"このスキーマ構造は間違い、visibilityはリスト単位"` — セクション全体の再構成指示

### 注釈反映時のルール

- 全注釈を漏れなく対応する
- 注釈の意図を正確に理解し、指示通りに修正する
- 不明点があれば確認する（勝手に解釈しない）
- 修正後も**実装には進まない**

## Phase 4: Todo List（タスクリスト作成）

ユーザーが計画を承認したら、実装前に粒度の細かいタスクリストを `plan.md` に追加する。

### 形式

```markdown
## Todo List

### Phase A: [フェーズ名]
- [ ] タスク1
- [ ] タスク2

### Phase B: [フェーズ名]
- [ ] タスク3
- [ ] タスク4
```

- 各タスクは1つの明確な作業単位
- 実装中に完了したら `[x]` にマーク
- 進捗がひと目で分かる粒度に設定

## Phase 5: Implementation（実装）

計画が完全に固まったら、一気に実装する。

### 実装開始時の標準指示

「全て実装せよ。タスク/フェーズ完了時は plan.md で完了マークを付けよ。全タスク・全フェーズ完了まで停止するな。」

### 実装中のルール

- plan.md が唯一の実装仕様。計画にないことはしない
- 完了タスクは即座に `[x]` マーク
- 型チェック・ビルドを継続的に実行
- 不要なコメント・JSDocは追加しない
- 実装は**機械的作業**。創造的判断はPhase 3で完了している

> **連携**: 実装フェーズでは `$implementation-rules` のルール（差分最小化、テスト要件、1機能1コミット）に従う。

## Phase 6: Feedback & Iterate（フィードバック）

実装後のユーザーからの修正指示は簡潔に対応する。

### 対応パターン

- **簡潔な修正指示**: 「この関数が未実装」「設定画面をadminアプリに移動して」
- **ビジュアル修正**: 「もっと広く」「2pxの隙間がある」（スクリーンショット活用）
- **既存コード参照**: 「ユーザーテーブルと同じ見た目にして」
- **リバート＆再スコープ**: 方向性が間違った場合、git変更を破棄して狭いスコープで再実装

### リバート判断基準

パッチで修正を重ねるより、リバートして再スコープした方が良い結果になることが多い。修正が3回以上重なったらリバートを検討する。

## 既存スキルとの連携

| フェーズ          | 使用スキル                                |
| ----------------- | ----------------------------------------- |
| Phase 1-4（計画） | 本スキル `research-plan-implement`        |
| Phase 5（実装）   | `$implementation-rules`（品質ルール適用） |
| コミット時        | `$git-ops`（コミットポリシー適用）        |
| iOSアプリ         | `$appium-simulator-test`（実操作検証）    |
