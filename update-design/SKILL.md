---
name: update-design
description: 設計書を作成・更新した後に発動。100点満点で自己評価し、不足点をタスクリストにして設計書を改善。矛盾や収載漏れがないことを最終確認する。
---

# 設計書の評価と改善

設計書を作成・更新した直後に実行する。
設計書の品質を100点満点で自己評価し、不足点を特定・改善し、最終的に矛盾や漏れがないことを確認する。

> [!IMPORTANT]
> このスキルはプロジェクトタイプに応じて評価カテゴリを動的に選択する。

---

## Phase 0: プロジェクトタイプの判定

設計書を評価する前に、プロジェクトタイプを特定する。

### 判定基準

| プロジェクトタイプ | 判定条件                                                                         |
| ------------------ | -------------------------------------------------------------------------------- |
| **iOS/macOS**      | `.xcodeproj`, `Package.swift`, `*.swift` が存在                                  |
| **Android**        | `build.gradle`, `*.kt`, `AndroidManifest.xml` が存在                             |
| **Web Frontend**   | `package.json` + React/Vue/Svelte依存                                            |
| **Web Backend**    | `package.json` + Express/Hono/Fastify、または `requirements.txt` + Flask/FastAPI |
| **Python**         | `requirements.txt`, `pyproject.toml`, `*.py` が存在                              |
| **General**        | 上記に該当しない場合                                                             |

プロジェクトタイプに応じて、Phase 2 の評価カテゴリを選択する。

---

## Phase 1: 設計書の読み込みと現状把握

### Step 1-1: 対象の特定

引数で指定された設計書、または直前に作成・更新した設計書を特定する。

設計書の一般的な配置場所:
- `docs/design/` - 設計ドキュメント
- `docs/` - 一般ドキュメント
- `<artifact_dir>/` - Claude artifacts（implementation_plan.md等）
- プロジェクト固有のパス（`rules.md` に記載があれば参照）

### Step 1-2: 設計書の全文読み込み

対象の設計書を全文読み込む。同時に、関連するソースコードも確認する。

---

## Phase 2: 100点満点の自己評価

プロジェクトタイプに応じた評価カテゴリを使用する。

### 共通カテゴリ（全プロジェクト共通: 50点）

| #   | カテゴリ                   | 配点 | 評価観点                                                 |
| --- | -------------------------- | ---- | -------------------------------------------------------- |
| 1   | **基本構造**               | 10点 | 必須セクション（概要・設計詳細・実装計画）が揃っているか |
| 2   | **目的・スコープの明確性** | 10点 | 何を実装するか、何を実装しないかが明確か                 |
| 3   | **エッジケース・異常系**   | 10点 | 境界条件、エラー処理、不正入力への対処が考慮されているか |
| 4   | **テスト戦略**             | 10点 | テストの方針と具体的なテストケースがあるか               |
| 5   | **実装計画**               | 10点 | Phase/Iteration分割、ファイル構成、依存関係が具体的か    |

### プロジェクト固有カテゴリ（50点）

#### iOS/macOS プロジェクト

| #   | カテゴリ               | 配点 | 評価観点                                                    |
| --- | ---------------------- | ---- | ----------------------------------------------------------- |
| 6   | **アーキテクチャ設計** | 10点 | MVVM/TCA/MVCの選択と理由、View-ViewModel-Model構成が明確か  |
| 7   | **SwiftUI/UIKit設計**  | 10点 | View構成、状態管理（@State, @Binding, @Observable）が適切か |
| 8   | **データ永続化**       | 10点 | SwiftData/CoreData/UserDefaultsの選択と設計が明確か         |
| 9   | **HIG準拠**            | 10点 | Human Interface Guidelines に沿ったUI/UX設計か              |
| 10  | **Concurrency設計**    | 10点 | async/await, Actor, MainActorの使用方針が明確か             |

#### Web Frontend プロジェクト

| #   | カテゴリ               | 配点 | 評価観点                                                             |
| --- | ---------------------- | ---- | -------------------------------------------------------------------- |
| 6   | **コンポーネント設計** | 10点 | コンポーネント分割、Props/State管理が適切か                          |
| 7   | **状態管理**           | 10点 | グローバル/ローカル状態の管理方針が明確か                            |
| 8   | **API連携**            | 10点 | データフェッチ、エラーハンドリング、キャッシュ戦略が考慮されているか |
| 9   | **アクセシビリティ**   | 10点 | WAI-ARIA、キーボード操作、スクリーンリーダー対応が考慮されているか   |
| 10  | **セキュリティ考慮**   | 10点 | XSS、CSRF、入力検証等が検討されているか                              |

#### Web Backend プロジェクト

| #   | カテゴリ                            | 配点 | 評価観点                                                                  |
| --- | ----------------------------------- | ---- | ------------------------------------------------------------------------- |
| 6   | **API設計**                         | 10点 | エンドポイント、リクエスト/レスポンス型、バリデーションが網羅されているか |
| 7   | **データベース設計**                | 10点 | スキーマ、マイグレーション、インデックス戦略が明確か                      |
| 8   | **認証認可**                        | 10点 | 認証フロー、権限管理、セッション管理が設計されているか                    |
| 9   | **エラーハンドリング**              | 10点 | エラーコード体系、ログ設計、リトライ戦略が明確か                          |
| 10  | **パフォーマンス/スケーラビリティ** | 10点 | キャッシュ、接続プーリング、負荷対策が考慮されているか                    |

#### General（汎用）

| #   | カテゴリ                 | 配点 | 評価観点                                             |
| --- | ------------------------ | ---- | ---------------------------------------------------- |
| 6   | **アーキテクチャ**       | 10点 | 全体構成、モジュール分割、依存関係が明確か           |
| 7   | **インターフェース設計** | 10点 | 公開API、型定義、利用方法が文書化されているか        |
| 8   | **セキュリティ考慮**     | 10点 | 機密データ、入力検証、アクセス制御が検討されているか |
| 9   | **運用考慮**             | 10点 | デプロイ、監視、ログ、バックアップが考慮されているか |
| 10  | **拡張性・保守性**       | 10点 | 将来の機能追加、変更への対応方針が明確か             |

### 採点基準（各カテゴリ共通）

| 点数 | 基準                             |
| ---- | -------------------------------- |
| 9-10 | 完璧。追加すべき内容がない       |
| 7-8  | 良好。軽微な追記で完成する       |
| 5-6  | 普通。重要な情報が一部欠けている |
| 3-4  | 不十分。大幅な追記が必要         |
| 1-2  | 骨格のみ。ほぼ未記述             |
| 0    | セクション自体が存在しない       |

### Step 2-1: 採点の実施

各カテゴリを採点し、以下のフォーマットで結果を出力する:

```markdown
## 自己評価結果

**プロジェクトタイプ**: [iOS/macOS | Web Frontend | Web Backend | General]

| #   | カテゴリ | 点数       | 評価コメント |
| --- | -------- | ---------- | ------------ |
| 1   | 基本構造 | X/10       | ...          |
| ... | ...      | ...        | ...          |
|     | **合計** | **XX/100** |              |
```

### Step 2-2: 重要度による分類

8点未満のカテゴリを改善対象として抽出し、優先度を付ける:

- **Critical（0-4点）**: 設計書として機能しない。即座に対応が必要
- **Major（5-6点）**: 実装着手に支障あり。改善が強く推奨される
- **Minor（7点）**: 品質向上のため推奨。なくても実装は可能

---

## Phase 3: 改善タスクリストの作成と設計書の更新

### Step 3-1: タスクリストの作成

Phase 2の評価結果から改善タスクを洗い出す。

タスクの粒度:
- 1タスク = 設計書の1セクションの追加・改善
- 具体的に何を書くかまで記述する（例: 「セキュリティセクションにXSS対策を追記」）

> [!NOTE]
> タスクは `task.md` アーティファクトで管理するか、設計書内に `## 改善タスク` セクションとして記載する。

### Step 3-2: タスクの実行（設計書の更新）

タスクリストに従い、設計書を更新する。

更新ルール:
- **既存の記述は尊重する**: 矛盾がない限り既存内容を変更しない
- **セクションの追加**: 不足しているセクションは既存設計書のフォーマットに合わせて追加
- **具体性を重視**: 抽象的な記述より、コード例・型定義・テーブルを含む具体的な記述
- **実装コードとの整合性**: ソースコードが既に存在する場合、実装と一致させる
- **日本語で記述**: 開発ドキュメントは日本語

### Step 3-3: 各タスク完了後の確認

タスクを1つ完了するごとに:
1. 該当セクションを再読して自然な文章になっているか確認
2. 前後のセクションとの整合性を確認

---

## Phase 4: 最終検証（矛盾・収載漏れチェック）

設計書の更新が完了したら、全文を再読して以下を検証する。

### Step 4-1: 内部一貫性チェック

- [ ] 概要セクションで述べたスコープと、実装計画でカバーされている範囲が一致しているか
- [ ] ファイル構成が設計詳細・実装計画の両方で一致しているか
- [ ] コード例のimport文やAPI呼び出しが、型定義と整合しているか
- [ ] 用語が統一されているか（同じ概念に異なる名前を使っていないか）

### Step 4-2: 収載漏れチェック

- [ ] 全ての主要機能に設計が記載されているか
- [ ] 全ての公開インターフェースに仕様が記載されているか
- [ ] エラー時の挙動が記載されているか
- [ ] 将来拡張として言及されている機能がPhase分割に含まれているか

### Step 4-3: ソースコードとの整合性

既に実装が存在する場合:

- [ ] 型名・クラス名がソースコードと一致しているか
- [ ] 関数シグネチャがソースコードと一致しているか
- [ ] ファイルパスが実際のディレクトリ構造と一致しているか

### Step 4-4: 問題が見つかった場合

矛盾や漏れが見つかった場合:
1. 問題箇所を特定する
2. 設計書を修正する
3. 再度 Step 4-1 〜 4-3 を実行する

問題がなくなるまで繰り返す（最大3回）。

---

## Phase 5: 評価結果の報告とユーザー承認

### Step 5-1: 評価レポートの作成

最終的な評価結果を以下のフォーマットで報告する:

```markdown
## 設計書評価レポート: <設計書名>

### 初回評価: XX/100点
### 改善後評価: YY/100点

### 改善内容
- <改善1>
- <改善2>
- ...

### 最終検証結果
- 内部一貫性: ✅ / ⚠️（詳細）
- 収載漏れ: ✅ / ⚠️（詳細）
- ソースコード整合性: ✅ / ⚠️（詳細） / N/A（未実装）
```

### Step 5-2: ユーザー承認の取得

> [!IMPORTANT]
> 設計書の更新内容について、`notify_user` ツールでユーザーに確認を求める。
> 承認を得てから次のアクションに進む。

### Step 5-3: 関連スキルとの連携

設計書の更新が承認されたら:

1. **git-ops**: 設計書の変更をコミット
2. **obsidian-brain**: 評価結果をセッションノートに記録（オプション）

---

## 注意事項

- 設計書が存在しない場合は、プロジェクトタイプに応じたテンプレートを提案する
- 甘い採点は禁止。実装に必要な情報が欠けていれば容赦なく減点する
- 評価は設計書の「実装着手に十分な情報があるか」を基準とする
- **90点以上**: 実装着手可能
- **80-89点**: 軽微な改善推奨だが着手可能
- **80点未満**: 実装着手前に設計書の改善が必要
- 評価完了後、ユーザーの承認なしに次のアクションに進まない
